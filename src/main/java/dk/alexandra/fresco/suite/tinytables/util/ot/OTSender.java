package dk.alexandra.fresco.suite.tinytables.util.ot;

import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.security.SecureRandom;

import org.bouncycastle.util.BigIntegers;

import edu.biu.scapi.exceptions.FactoriesException;
import edu.biu.scapi.interactiveMidProtocols.ot.OTOnByteArraySInput;
import edu.biu.scapi.interactiveMidProtocols.ot.OTRGroupElementPairMsg;
import edu.biu.scapi.interactiveMidProtocols.ot.OTSInput;
import edu.biu.scapi.interactiveMidProtocols.ot.OTSMsg;
import edu.biu.scapi.interactiveMidProtocols.ot.semiHonest.OTSemiHonestDDHOnByteArraySenderMsg;
import edu.biu.scapi.primitives.dlog.GroupElement;
import edu.biu.scapi.primitives.dlog.bc.BcDlogECF2m;
import edu.biu.scapi.primitives.kdf.KeyDerivationFunction;
import edu.biu.scapi.tools.Factories.KdfFactory;

/**
 * Implementation of an semi-honest OT sender. Most of the code is taken from <a
 * href="https://github.com/cryptobiu/scapi">SCAPI</a>, but it is changed to
 * allow easier usage in FRESCO. In particular we make it possible to extract
 * the messages from the OT protocol.
 * 
 * @author jonas
 *
 */
public class OTSender {

	private BcDlogECF2m dlog;
	private KeyDerivationFunction kdf;
	private SecureRandom random;
	private BigInteger qMinusOne;

	public OTSender() {
		try {
			dlog = new edu.biu.scapi.primitives.dlog.bc.BcDlogECF2m();
			kdf = KdfFactory.getInstance().getObject("HKDF(HMac(SHA-256))");
		} catch (IOException e) {
			e.printStackTrace();
		} catch (FactoriesException e) {
			e.printStackTrace();
		}

		random = new SecureRandom();
		qMinusOne = dlog.getOrder().subtract(BigInteger.ONE);
	}

	/**
	 * 
	 * @param firsts
	 *            An array of messages generated by {@link OTReceiver#createFirstMessages(byte)}.
	 * @param input0
	 * @param input1
	 * @return
	 */
	public Serializable createSecondMessages(Serializable firsts, byte[][] input0, byte[][] input1) {
		
		OTRGroupElementPairMsg[] messages = (OTRGroupElementPairMsg[]) firsts;

		OTSMsg[] responses = new OTSMsg[messages.length];
		
		//SAMPLE a single random value r in  [0, . . . , q-1] 
		BigInteger r = BigIntegers.createRandomInRange(BigInteger.ZERO, qMinusOne, random);
		
		//Calculate u = g^r.
		GroupElement u = computeU(r);
		
		for (int i = 0; i < messages.length; i++) {
			GroupElement k0 = computeK0(r, messages[i]);
			GroupElement k1 = computeK1(r, messages[i]);
			
			responses[i] = computeTuple(new OTOnByteArraySInput(input0[i], input1[i]), u, k0, k1);
			
		}
		return responses;
	}

	/**
	 * Runs the following line from the protocol: "COMPUTE u = g^r"
	 * 
	 * @param r
	 *            the exponent
	 * @return the computed u.
	 */
	private GroupElement computeU(BigInteger r) {
		GroupElement g = dlog.getGenerator(); // Get the group generator.

		// Calculate u = g^r.
		return dlog.exponentiate(g, r);
	}

	/**
	 * Runs the following line from the protocol: "COMPUTE k0 = h0^r"
	 * 
	 * @param r
	 *            the exponent
	 * @param message
	 *            contains h0
	 * @return the computed k0
	 */
	private GroupElement computeK0(BigInteger r, OTRGroupElementPairMsg message) {

		// Recreate h0 from the data in the received message.
		GroupElement h0 = dlog.reconstructElement(true, message.getFirstGE());

		// Calculate k0 = h0^r.
		return dlog.exponentiate(h0, r);
	}

	/**
	 * Runs the following line from the protocol: "COMPUTE k1 = h1^r"
	 * 
	 * @param r
	 *            the exponent
	 * @param message
	 *            contains h1
	 * @return the computed k1
	 */
	private GroupElement computeK1(BigInteger r, OTRGroupElementPairMsg message) {

		// Recreate h0, h1 from the data in the received message.
		GroupElement h1 = dlog.reconstructElement(true, message.getSecondGE());

		// Calculate k1 = h1^r.
		return dlog.exponentiate(h1, r);
	}

	/**
	 * Runs the following lines from the protocol: "COMPUTE: v0 = x0 XOR
	 * KDF(|x0|,k0) v1 = x1 XOR KDF(|x1|,k1)"
	 * 
	 * @param input
	 *            MUST be an instance of OTSOnByteArrayInput
	 * @param k1
	 * @param k0
	 * @param u
	 * @return tuple contains (u, v0, v1) to send to the receiver.
	 */
	private OTSMsg computeTuple(OTSInput input, GroupElement u, GroupElement k0, GroupElement k1) {
		// If input is not instance of OTSOnByteArrayInput, throw Exception.
		if (!(input instanceof OTOnByteArraySInput)) {
			throw new IllegalArgumentException("x0 and x1 should be binary strings.");
		}

		byte[] x0 = ((OTOnByteArraySInput) input).getX0();
		byte[] x1 = ((OTOnByteArraySInput) input).getX1();

		// If x0, x1 are not of the same length, throw Exception.
		if (x0.length != x1.length) {
			throw new IllegalArgumentException("x0 and x1 should be of the same length.");
		}

		// Calculate v0:
		byte[] k0Bytes = dlog.mapAnyGroupElementToByteArray(k0);

		int len = x0.length;
		byte[] v0 = kdf.deriveKey(k0Bytes, 0, k0Bytes.length, len).getEncoded();

		// Xores the result from the kdf with x0.
		for (int i = 0; i < len; i++) {
			v0[i] = (byte) (v0[i] ^ x0[i]);
		}

		// Calculate v1:
		byte[] k1Bytes = dlog.mapAnyGroupElementToByteArray(k1);
		byte[] v1 = kdf.deriveKey(k1Bytes, 0, k1Bytes.length, len).getEncoded();

		// Xores the result from the kdf with x1.
		for (int i = 0; i < len; i++) {
			v1[i] = (byte) (v1[i] ^ x1[i]);
		}

		// Create and return sender message.
		return new OTSemiHonestDDHOnByteArraySenderMsg(u.generateSendableData(), v0, v1);
	}
}
